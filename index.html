<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Множество Мандельброта</title>
    <style>
      body {
        display: flex;
        flex-direction: row;
        align-items: center;
        height: 100vh;
        margin: 0;
        background-color: #000;
        overflow: hidden;
      }
      canvas {
        border: 1px solid #fff;
        background: black;
        width: 800px;
        height: 800px;
      }
      #controls {
        margin: 10px;
        display: flex;
        flex-wrap: wrap;
      }
      button {
        margin: 5px;
        padding: 10px;
        font-size: 16px;
      }
      #info {
        color: white;
        margin: 10px;
      }

      @media screen and (max-width: 600px) {
        body {
          flex-direction: column;
        }

        canvas {
          width: 100vw !important;
          height: 100vw !important;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="mandelbrotCanvas" width="800" height="800"></canvas>
    <div class="desc">
      <div id="info"></div>
      <div id="controls">
        <button id="point1">(-0.75, 0.186)</button>
        <button id="point2">(-0.745, 0.186)</button>
        <button id="point3">(-0.8, 0.156)</button>
        <button id="point4">(-0.4, 0.6)</button>
        <button id="point5">(-1.5, 0)</button>
        <button id="reset">Сброс</button>
        <button id="autoZoom">Авто zoom</button>
        <button id="colorBlackWhite">Черно-белый</button>
        <button id="colorRGB">RGB</button>
        <button id="colorRainbow">Радуга</button>
        <button id="saveImage">Сохранить изображение</button>
        <button id="zoomIn">+</button>
        <button id="zoomOut">-</button>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("mandelbrotCanvas");
      const ctx = canvas.getContext("2d");
      const width = 800;
      const height = 800;

      const widthToZoom = parseInt(window.getComputedStyle(canvas).width);
      const heightToZoom = parseInt(window.getComputedStyle(canvas).height);

      document.getElementById("saveImage").addEventListener("click", () => {
        const link = document.createElement("a");
        link.download = "mandelbrot.png"; // The name for the downloaded file
        link.href = canvas.toDataURL("image/png"); // Get the data URL of the canvas
        link.click(); // Trigger the download
      });

      let xMin = -2;
      let xMax = 2;
      let yMin = -2;
      let yMax = 2;
      let maxIter = 100;
      let colorMode = "RGB"; // Default color mode

      function getDefaultBgColor() {
        return [0, 255, 255];
      }

      function mandelbrot() {
        const imageData = ctx.createImageData(width, height);
        const data = imageData.data;

        for (let x = 0; x < width; x++) {
          for (let y = 0; y < height; y++) {
            let zx = 0;
            let zy = 0;
            let i = maxIter;
            const cX = xMin + (x / width) * (xMax - xMin);
            const cY = yMin + (y / height) * (yMax - yMin);

            while (zx * zx + zy * zy < 4 && i > 0) {
              const tmp = zx * zx - zy * zy + cX;
              zy = 2 * zx * zy + cY;
              zx = tmp;
              i--;
            }

            const pixelIndex = (x + y * width) * 4;

            if (i > maxIter - 30) {
              const col = getDefaultBgColor();
              data[pixelIndex] = col[0]; // Red
              data[pixelIndex + 1] = col[1]; // Green
              data[pixelIndex + 2] = col[2]; // Blue
              data[pixelIndex + 3] = 255; // Alpha
              continue;
            }

            // Color assignment based on color mode
            if (colorMode === "BlackWhite") {
              const shade = (i / maxIter) * 255; // Create a gray shade based on iterations
              data[pixelIndex] = shade; // Red
              data[pixelIndex + 1] = shade; // Green
              data[pixelIndex + 2] = shade; // Blue
            } else if (colorMode === "RGB") {
              if (i === 0) {
                data[pixelIndex] = 0; // Red
                data[pixelIndex + 1] = 0; // Green
                data[pixelIndex + 2] = 0; // Blue
              } else {
                const r = (i % 8) * 32;
                const g = (i % 16) * 16;
                const b = (i % 32) * 8;
                data[pixelIndex] = r;
                data[pixelIndex + 1] = g;
                data[pixelIndex + 2] = b;
              }
            } else if (colorMode === "Rainbow") {
              if (i === 0) {
                data[pixelIndex] = 0; // Red
                data[pixelIndex + 1] = 0; // Green
                data[pixelIndex + 2] = 0; // Blue
              } else {
                const hue = (i / maxIter) * 360; // Color angle in HSL
                const rgb = hslToRgb(hue / 360, 1, 0.5); // Convert HSL to RGB
                data[pixelIndex] = rgb[0];
                data[pixelIndex + 1] = rgb[1];
                data[pixelIndex + 2] = rgb[2];
              }
            }
            data[pixelIndex + 3] = 255; // Alpha
          }
        }
        ctx.putImageData(imageData, 0, 0);
        updateInfo();
      }

      function hslToRgb(h, s, l) {
        let r, g, b;
        if (s === 0) {
          r = g = b = l; // achromatic
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          };
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
      }

      function zoomIn(xMouse, yMouse) {
        const zoomFactor = 0.5; // Увеличение в 2 раза
        const xCenter = xMin + (xMouse / widthToZoom) * (xMax - xMin);
        const yCenter = yMin + (yMouse / heightToZoom) * (yMax - yMin);

        console.log(xCenter, yCenter, yMouse, widthToZoom);
        xMin = xCenter + (xMin - xCenter) * zoomFactor;
        xMax = xCenter + (xMax - xCenter) * zoomFactor;
        yMin = yCenter + (yMin - yCenter) * zoomFactor;
        yMax = yCenter + (yMax - yCenter) * zoomFactor;

        mandelbrot();
      }

      function zoomInAuto() {
        const zoomFactor = 0.9;
        const xCenter = xMin + (widthToZoom / 2 / widthToZoom) * (xMax - xMin);
        const yCenter =
          yMin + (heightToZoom / 2 / heightToZoom) * (yMax - yMin);

        xMin = xCenter + (xMin - xCenter) * zoomFactor;
        xMax = xCenter + (xMax - xCenter) * zoomFactor;
        yMin = yCenter + (yMin - yCenter) * zoomFactor;
        yMax = yCenter + (yMax - yCenter) * zoomFactor;

        mandelbrot();
      }

      let autoZoomInterval;

      document
        .getElementById("point1")
        .addEventListener("click", () => setPoint(-0.75, -0.74, 0.186, 0.187));
      document
        .getElementById("point2")
        .addEventListener("click", () => setPoint(-0.745, -0.739, 0.186, 0.19));
      document
        .getElementById("point3")
        .addEventListener("click", () => setPoint(-0.8, -0.79, 0.156, 0.157));
      document
        .getElementById("point4")
        .addEventListener("click", () =>
          setPoint(
            -0.47658135381313224,
            -0.27658135381313224,
            0.5622053085935699,
            0.7622053085935699
          )
        );
      document
        .getElementById("point5")
        .addEventListener("click", () => setPoint(-1.5, -1.4, 0, 0.1));
      document.getElementById("reset").addEventListener("click", reset);
      document.getElementById("autoZoom").addEventListener("click", () => {
        autoZoomInterval = setInterval(() => {
          zoomInAuto();
        }, 200);
      });

      // canvas.addEventListener("touchstart", (event) => {
      //   if (event.touches.length === 2) {
      //     const dx = event.touches[0].clientX - event.touches[1].clientX;
      //     const dy = event.touches[0].clientY - event.touches[1].clientY;
      //     lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
      //   }
      // });

      // canvas.addEventListener("touchmove", (event) => {
      //   if (event.touches.length === 2 && lastTouchDistance !== null) {
      //     const dx = event.touches[0].clientX - event.touches[1].clientX;
      //     const dy = event.touches[0].clientY - event.touches[1].clientY;
      //     const currentTouchDistance = Math.sqrt(dx * dx + dy * dy);

      //     const zoomFactor = currentTouchDistance / lastTouchDistance;

      //     const rect = canvas.getBoundingClientRect();
      //     const xMouse = (event.touches[0].clientX - rect.left) / width;
      //     const yMouse = (event.touches[0].clientY - rect.top) / height;
      //     const xCenter = xMin + xMouse * (xMax - xMin);
      //     const yCenter = yMin + yMouse * (yMax - yMin);

      //     xMin = xCenter + (xMin - xCenter) / zoomFactor;
      //     xMax = xCenter + (xMax - xCenter) / zoomFactor;
      //     yMin = yCenter + (yMin - yCenter) / zoomFactor;
      //     yMax = yCenter + (yMax - yCenter) / zoomFactor;

      //     mandelbrot();
      //     lastTouchDistance = currentTouchDistance;
      //   }
      // });

      // canvas.addEventListener("touchend", () => {
      //   lastTouchDistance = null;
      // });

      document
        .getElementById("colorBlackWhite")
        .addEventListener("click", () => {
          colorMode = "BlackWhite";
          mandelbrot();
        });

      document.getElementById("colorRGB").addEventListener("click", () => {
        colorMode = "RGB";
        mandelbrot();
      });

      document.getElementById("colorRainbow").addEventListener("click", () => {
        colorMode = "Rainbow";
        mandelbrot();
      });

      canvas.addEventListener("wheel", (event) => {
        const zoomDiff = 0.5;
        const zoomFactor = event.deltaY > 0 ? 1 + zoomDiff : 1 - zoomDiff; // Увеличение или уменьшение в 1.1 раза
        const rect = canvas.getBoundingClientRect();
        const xMouse = event.clientX - rect.left;
        const yMouse = event.clientY - rect.top;
        const xCenter = xMin + (xMouse / widthToZoom) * (xMax - xMin);
        const yCenter = yMin + (yMouse / heightToZoom) * (yMax - yMin);

        xMin = xCenter + (xMin - xCenter) / zoomFactor;
        xMax = xCenter + (xMax - xCenter) / zoomFactor;
        yMin = yCenter + (yMin - yCenter) / zoomFactor;
        yMax = yCenter + (yMax - yCenter) / zoomFactor;

        mandelbrot();
      });

      document.getElementById("zoomIn").addEventListener("click", zoomIn);
      document.getElementById("zoomOut").addEventListener("click", zoomOut);

      function updateInfo() {
        const centerX = (xMin + xMax) / 2;
        const centerY = (yMin + yMax) / 2;
        const zoomLevel = Math.abs(xMax - xMin);
        document.getElementById(
          "info"
        ).innerText = `Координаты: (${centerX.toFixed(3)}, ${centerY.toFixed(
          3
        )}) | Длинна стороны: ${toScientificNotation(zoomLevel)}`;
      }

      function toScientificNotation(num, decimalPlaces = 4) {
        if (num > 1 / 10 ** decimalPlaces) {
          return num.toFixed(decimalPlaces);
        }
        return num.toExponential(decimalPlaces);
      }

      function reset() {
        xMin = -2;
        xMax = 2;
        yMin = -2;
        yMax = 2;
        maxIter = 400;
        colorMode = "RGB"; // Reset to default color mode
        mandelbrot();
      }

      function setPoint(xMinValue, xMaxValue, yMinValue, yMaxValue) {
        xMin = xMinValue;
        xMax = xMaxValue;
        yMin = yMinValue;
        yMax = yMaxValue;
        mandelbrot();
      }

      function zoomIn() {
        const zoomFactor = 0.5; // Увеличение в 2 раза
        const xCenter = (xMin + xMax) / 2;
        const yCenter = (yMin + yMax) / 2;

        xMin = xCenter + (xMin - xCenter) * zoomFactor;
        xMax = xCenter + (xMax - xCenter) * zoomFactor;
        yMin = yCenter + (yMin - yCenter) * zoomFactor;
        yMax = yCenter + (yMax - yCenter) * zoomFactor;

        mandelbrot();
      }

      function zoomOut() {
        const zoomFactor = 0.5; // Уменьшение в 2 раза
        const xCenter = (xMin + xMax) / 2;
        const yCenter = (yMin + yMax) / 2;

        xMin = xCenter + (xMin - xCenter) / zoomFactor;
        xMax = xCenter + (xMax - xCenter) / zoomFactor;
        yMin = yCenter + (yMin - yCenter) / zoomFactor;
        yMax = yCenter + (yMax - yCenter) / zoomFactor;

        mandelbrot();
      }

      document.getElementById("zoomIn").addEventListener("click", zoomIn);
      document.getElementById("zoomOut").addEventListener("click", zoomOut);

      let isDragging = false;
      let offsetX = 0;
      let offsetY = 0;

      canvas.addEventListener("mousedown", (event) => {
        isDragging = true;
        const rect = canvas.getBoundingClientRect();
        offsetX = event.clientX - rect.left;
        offsetY = event.clientY - rect.top;
      });

      canvas.addEventListener("mousemove", (event) => {
        if (isDragging) {
          const rect = canvas.getBoundingClientRect();
          const newX = event.clientX - rect.left;
          const newY = event.clientY - rect.top;
          const dx = newX - offsetX;
          const dy = newY - offsetY;

          xMin -= (dx / width) * (xMax - xMin);
          xMax -= (dx / width) * (xMax - xMin);
          yMin -= (dy / height) * (yMax - yMin);
          yMax -= (dy / height) * (yMax - yMin);

          offsetX = newX;
          offsetY = newY;

          mandelbrot();
        }
      });

      canvas.addEventListener("mouseup", () => {
        isDragging = false;
      });

      // Touch events for mobile devices
      canvas.addEventListener("touchstart", (event) => {
        isDragging = true;
        const rect = canvas.getBoundingClientRect();
        const touch = event.touches[0];
        offsetX = touch.clientX - rect.left;
        offsetY = touch.clientY - rect.top;
      });

      canvas.addEventListener("touchmove", (event) => {
        if (isDragging) {
          const rect = canvas.getBoundingClientRect();
          const touch = event.touches[0];
          const newX = touch.clientX - rect.left;
          const newY = touch.clientY - rect.top;
          const dx = newX - offsetX;
          const dy = newY - offsetY;

          xMin -= (dx / width) * (xMax - xMin);
          xMax -= (dx / width) * (xMax - xMin);
          yMin -= (dy / height) * (yMax - yMin);
          yMax -= (dy / height) * (yMax - yMin);

          offsetX = newX;
          offsetY = newY;

          mandelbrot();
        }
      });

      canvas.addEventListener("touchend", () => {
        isDragging = false;
      });

      mandelbrot();
    </script>
  </body>
</html>
