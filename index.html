<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Множество Мандельброта</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 100vh;
        margin: 0;
        background-color: #000;
      }
      canvas {
        border: 1px solid #fff;
      }
      #controls {
        margin: 10px;
      }
      button {
        margin: 5px;
        padding: 10px;
        font-size: 16px;
      }
    </style>
  </head>
  <body>
    <canvas id="mandelbrotCanvas" width="800" height="800"></canvas>
    <div id="controls">
      <button id="point1">(-0.75, 0.186)</button>
      <button id="point2">(-0.745, 0.186)</button>
      <button id="point3">(-0.8, 0.156)</button>
      <button id="point4">(-0.4, 0.6)</button>
      <button id="point5">(-1.5, 0)</button>
      <button id="reset">Сброс</button>
      <button id="autoZoom">Авто zoom</button>
    </div>

    <div id="info" style="color: white; margin: 10px"></div>

    <script>
      const canvas = document.getElementById("mandelbrotCanvas");
      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;

      // Начальные значения для зума
      let xMin = -2;
      let xMax = 2;
      let yMin = -2;

      let yMax = 2;
      let maxIter = 1000;

      function mandelbrot() {
        const imageData = ctx.createImageData(width, height);
        const data = imageData.data;

        for (let x = 0; x < width; x++) {
          for (let y = 0; y < height; y++) {
            let zx = 0;
            let zy = 0;
            let i = maxIter;
            const cX = xMin + (x / width) * (xMax - xMin);
            const cY = yMin + (y / height) * (yMax - yMin);

            while (zx * zx + zy * zy < 4 && i > 0) {
              const tmp = zx * zx - zy * zy + cX;
              zy = 2 * zx * zy + cY;
              zx = tmp;
              i--;
            }

            const pixelIndex = (x + y * width) * 4;

            // Условие для закрашивания черным
            if (i === 0) {
              data[pixelIndex] = 0; // Red
              data[pixelIndex + 1] = 0; // Green
              data[pixelIndex + 2] = 0; // Blue
            } else {
              // Цвета для точек, которые находятся в пределах множества
              const r = (i % 8) * 32;
              const g = (i % 16) * 16;
              const b = (i % 32) * 8;

              data[pixelIndex] = r;
              data[pixelIndex + 1] = g;
              data[pixelIndex + 2] = b;
            }
            data[pixelIndex + 3] = 255; // Alpha
          }
        }
        ctx.putImageData(imageData, 0, 0);
      }

      function zoomIn(xMouse, yMouse) {
        const zoomFactor = 0.5; // Увеличение в 2 раза
        const xCenter = xMin + (xMouse / width) * (xMax - xMin);
        const yCenter = yMin + (yMouse / height) * (yMax - yMin);

        xMin = xCenter + (xMin - xCenter) * zoomFactor;
        xMax = xCenter + (xMax - xCenter) * zoomFactor;
        yMin = yCenter + (yMin - yCenter) * zoomFactor;
        yMax = yCenter + (yMax - yCenter) * zoomFactor;

        mandelbrot();
      }

      function reset() {
        xMin = -2;
        xMax = 2;
        yMin = -2;
        yMax = 2;
        maxIter = 100;
        clearInterval(autoZoomInterval);
        mandelbrot();
      }

      function setPoint(xMinValue, xMaxValue, yMinValue, yMaxValue) {
        xMin = xMinValue;
        xMax = xMaxValue;
        yMin = yMinValue;
        yMax = yMaxValue;
        mandelbrot();
      }

      function zoomInAuto() {
        const zoomFactor = 0.9;
        const xCenter = xMin + (width / 2 / width) * (xMax - xMin);
        const yCenter = yMin + (height / 2 / height) * (yMax - yMin);

        xMin = xCenter + (xMin - xCenter) * zoomFactor;
        xMax = xCenter + (xMax - xCenter) * zoomFactor;
        yMin = yCenter + (yMin - yCenter) * zoomFactor;
        yMax = yCenter + (yMax - yCenter) * zoomFactor;

        mandelbrot();
      }

      let autoZoomInterval;

      document
        .getElementById("point1")
        .addEventListener("click", () => setPoint(-0.75, -0.74, 0.186, 0.187));
      document
        .getElementById("point2")
        .addEventListener("click", () => setPoint(-0.745, -0.739, 0.186, 0.19));
      document
        .getElementById("point3")
        .addEventListener("click", () => setPoint(-0.8, -0.79, 0.156, 0.157));
      document
        .getElementById("point4")
        .addEventListener("click", () => setPoint(-0.4, -0.3, 0.6, 0.7));
      document
        .getElementById("point5")
        .addEventListener("click", () => setPoint(-1.5, -1.4, 0, 0.1));
      document.getElementById("reset").addEventListener("click", reset);
      document.getElementById("autoZoom").addEventListener("click", () => {
        autoZoomInterval = setInterval(() => {
          zoomInAuto();
        }, 200);
      });

      canvas.addEventListener("wheel", (event) => {
        const zoomDiff = 0.5;
        const zoomFactor = event.deltaY > 0 ? 1 + zoomDiff : 1 - zoomDiff; // Увеличение или уменьшение в 1.1 раза
        const rect = canvas.getBoundingClientRect();
        const xMouse = event.clientX - rect.left;
        const yMouse = event.clientY - rect.top;
        const xCenter = xMin + (xMouse / width) * (xMax - xMin);
        const yCenter = yMin + (yMouse / height) * (yMax - yMin);

        xMin = xCenter + (xMin - xCenter) / zoomFactor;
        xMax = xCenter + (xMax - xCenter) / zoomFactor;
        yMin = yCenter + (yMin - yCenter) / zoomFactor;
        yMax = yCenter + (yMax - yCenter) / zoomFactor;

        mandelbrot();
      });

      let isDragging = false;
      let offsetX = 0;
      let offsetY = 0;

      canvas.addEventListener("mousedown", (event) => {
        isDragging = true;
        const rect = canvas.getBoundingClientRect();
        offsetX = event.clientX - rect.left;
        offsetY = event.clientY - rect.top;
      });

      canvas.addEventListener("mousemove", (event) => {
        if (isDragging) {
          const rect = canvas.getBoundingClientRect();
          const newX = event.clientX - rect.left;
          const newY = event.clientY - rect.top;
          const dx = newX - offsetX;
          const dy = newY - offsetY;

          xMin -= (dx / width) * (xMax - xMin);
          xMax -= (dx / width) * (xMax - xMin);
          yMin -= (dy / height) * (yMax - yMin);
          yMax -= (dy / height) * (yMax - yMin);

          offsetX = newX;
          offsetY = newY;

          mandelbrot();
        }
      });

      canvas.addEventListener("mouseup", () => {
        isDragging = false;
      });

      mandelbrot();
    </script>
  </body>
</html>
